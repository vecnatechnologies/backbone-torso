<!DOCTYPE html>

<html>
<head>
  <title>ListView.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="../docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>ListView.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root, factory</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">'function'</span> &amp;&amp; define.amd) {
    define([<span class="hljs-string">'underscore'</span>, <span class="hljs-string">'backbone'</span>, <span class="hljs-string">'./View'</span>, <span class="hljs-string">'./templateRenderer'</span>], factory);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> exports === <span class="hljs-string">'object'</span>) {
    <span class="hljs-built_in">module</span>.exports = factory(<span class="hljs-built_in">require</span>(<span class="hljs-string">'underscore'</span>), <span class="hljs-built_in">require</span>(<span class="hljs-string">'backbone'</span>), <span class="hljs-built_in">require</span>(<span class="hljs-string">'./View'</span>), <span class="hljs-built_in">require</span>(<span class="hljs-string">'./templateRenderer'</span>));
  } <span class="hljs-keyword">else</span> {
    root.Torso = root.Torso || {};
    root.Torso.ListView = factory(root._, root.Backbone, root.Torso.View, root.Torso.Utils.templateRenderer);
  }
}(<span class="hljs-keyword">this</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">_, Backbone, View, templateRenderer</span>) </span>{
<span class="hljs-meta">  'use strict'</span>;

    <span class="hljs-keyword">var</span> removeItemView, _removeItemView, addItemView, _addItemView, aggregateRenders, breakDelayedRender;

    <span class="hljs-keyword">var</span> $ = Backbone.$;

    <span class="hljs-comment">/**
     * If one exists, this method will clear the delayed render timeout and invoke render
     * @param {ListView} view the list view
     * @private
     */</span>
    breakDelayedRender = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">view</span>) </span>{
      <span class="hljs-keyword">if</span> (view.__delayedRenderTimeout) {
        clearTimeout(view.__delayedRenderTimeout);
        view.__delayedRenderTimeout = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">if</span> (!view.isDisposed()) {
          view.render();
        }
      }
    };

    <span class="hljs-comment">/**
     * Aggregates calls to render by waiting a certain amount of time and then rendering.
     * Calls that happen while it is waiting, will be swallowed. Useful for when you want to
     * batch render calls
     * @private
     * @param {number} wait the number of milliseconds to wait before rendering
     * @param {ListView} view the list view
     */</span>
    aggregateRenders = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">wait, view</span>) </span>{
      <span class="hljs-keyword">var</span> postpone = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        view.__delayedRenderTimeout = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">if</span> (!view.isDisposed()) {
          view.render();
        }
      };
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (!view.__delayedRenderTimeout &amp;&amp; wait &gt; <span class="hljs-number">0</span>) {
          view.__delayedRenderTimeout = setTimeout(postpone, wait);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wait &lt;= <span class="hljs-number">0</span> &amp;&amp; !view.isDisposed()) {
          view.render();
        }
      };
    };

    <span class="hljs-comment">/**
     * Handles the removal of an item view if a model has been removed from the collection
     * @private
     * @param {Backbone Model instance} model the model that has been removed
     */</span>
    removeItemView = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model</span>) </span>{
      <span class="hljs-keyword">var</span> itemView = <span class="hljs-keyword">this</span>.getItemViewFromModel(model);
      <span class="hljs-keyword">if</span> (itemView) {
        _removeItemView.call(<span class="hljs-keyword">this</span>, itemView, model[<span class="hljs-keyword">this</span>.__modelId], model);
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.hasItemViews()) {
          <span class="hljs-keyword">this</span>.__delayedRender();
        }
      }
    };

    <span class="hljs-comment">/**
     * Disposes of an item view, unregisters, stops tracking and triggers a 'item-view-removed' event
     * with the model and an item view as the payload.
     * @private
     * @param {Backbone View instance} itemView the view being removed
     * @param {string|Number} modelId the id used for the model
     * @param {Backbone Model instance} [model] the model
     */</span>
    _removeItemView = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">itemView, modelId, model</span>) </span>{
      itemView.dispose();
      <span class="hljs-keyword">this</span>.unregisterTrackedView(itemView, { <span class="hljs-attr">shared</span>: <span class="hljs-literal">false</span> });
      <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.__modelToViewMap[modelId];
      <span class="hljs-keyword">this</span>.__updateOrderedModelIdList();
      <span class="hljs-keyword">this</span>.trigger(<span class="hljs-string">'item-view-removed'</span>, {<span class="hljs-attr">model</span>: model || itemView.model, <span class="hljs-attr">view</span>: itemView});
      <span class="hljs-keyword">this</span>.trigger(<span class="hljs-string">'child-view-removed'</span>, {<span class="hljs-attr">model</span>: model || itemView.model, <span class="hljs-attr">view</span>: itemView});
    };

    <span class="hljs-comment">/**
     * Handles the addition of an item view if a model has been added to the collection.
     * When possible, it will append the view instead of causing a rerender
     * @private
     * @param model the model being added
     */</span>
    addItemView = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model</span>) </span>{
      <span class="hljs-keyword">var</span> itemView,
          models = <span class="hljs-keyword">this</span>.modelsToRender(),
          indexOfModel = models.indexOf(model);
      <span class="hljs-keyword">if</span> (indexOfModel &gt; <span class="hljs-number">-1</span>) {
        itemView = <span class="hljs-keyword">this</span>.__createItemView(model);
        _addItemView.call(<span class="hljs-keyword">this</span>, itemView, indexOfModel);
      }
    };

    <span class="hljs-comment">/**
     * Adds the new item view before or after a sibling view. If no sibling view exists
     * or if this item view is the first, it will cause a re-render. This method will break
     * any delayed renders and force a re-render before continuing.
     * @private
     * @param itemView the view being added
     * @param indexOfModel - the index of the model into the array of models to render
     */</span>
    _addItemView = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">itemView, indexOfModel</span>) </span>{
      <span class="hljs-keyword">var</span> viewAfter, viewBefore, replaceMethod,
        models = <span class="hljs-keyword">this</span>.modelsToRender();
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.hasItemViews()) {
        <span class="hljs-keyword">this</span>.__delayedRender();
      } <span class="hljs-keyword">else</span> {
        breakDelayedRender(<span class="hljs-keyword">this</span>);
        viewAfter = <span class="hljs-keyword">this</span>.getItemViewFromModel(models[indexOfModel + <span class="hljs-number">1</span>]);
        viewBefore = <span class="hljs-keyword">this</span>.getItemViewFromModel(models[indexOfModel - <span class="hljs-number">1</span>]);
        <span class="hljs-keyword">if</span> (viewAfter) {
          replaceMethod = _.bind(viewAfter.$el.before, viewAfter.$el);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (viewBefore) {
          replaceMethod = _.bind(viewBefore.$el.after, viewBefore.$el);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">this</span>.__delayedRender();
        }
        <span class="hljs-keyword">if</span> (replaceMethod) {
          <span class="hljs-keyword">this</span>.attachView(<span class="hljs-literal">null</span>, itemView, {
            <span class="hljs-attr">replaceMethod</span>: replaceMethod,
            <span class="hljs-attr">discardInjectionSite</span>: <span class="hljs-literal">true</span>
          });
        }
      }
    };

  <span class="hljs-comment">/**
   * A view that is backed by a collection that managers views per model in the collection.
   * @module    Torso
   * @class     ListView
   * @constructor
   * @author ariel.wexler@vecna.com, kent.willis@vecna.com
   */</span>
  <span class="hljs-keyword">var</span> ListView = View.extend({
    <span class="hljs-comment">/**
     * The collection that holds the models that this list view will track
     * @property collection
     * @type Collection
     */</span>
    collection: <span class="hljs-literal">null</span>,
    <span class="hljs-comment">/**
     * The item view class definition that will be instantiated for each model in the list.
     * itemView can also be a function that takes a model and returns a view class. This allows
     * for different view classes depending on the model.
     * @property itemView
     * @type View or Function
     */</span>
    itemView: <span class="hljs-literal">null</span>,
    <span class="hljs-comment">/**
     * The template that allows a list view to hold it's own HTML like filter buttons, etc.
     * @property template
     * @type HTML Template
     */</span>
    template: <span class="hljs-literal">null</span>,
    <span class="hljs-comment">/**
     * If provided, this template that will be shown if the modelsToRender() method returns
     * an empty list. If an itemContainer is provided, the empty template will be rendered there.
     * @property emptyTemplate
     * @type HTML Template
     */</span>
    emptyTemplate: <span class="hljs-literal">null</span>,
    <span class="hljs-comment">/**
     * (Required if 'template' is provided, ignored otherwise) name of injection site for list of item views
     * @property itemContainer
     * @type String
     */</span>
    itemContainer: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">__modelName</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">__modelId</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">__modelToViewMap</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">__itemContext</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">__renderWait</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">__delayedRender</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-comment">/**
     * @property __delayedRenderTimeout
     * @private
     * @type {number}
     */</span>
    __delayedRenderTimeout: <span class="hljs-literal">null</span>,

    <span class="hljs-comment">/**
     * Constructor for the list view object.
     * @param {Object} args - options argument
     *   @param {Backbone.View definition or Function} args.itemView - the class definition of the item view. This view will be instantiated for every model returned by modelsToRender(). If a function is passed in, then for each model, this function will be invoked to find the appropriate view class. It takes the model as the only parameter.
     *   @param {Backbone.Collection instance} args.collection - The collection that will back this list view. A subclass of list view might provide a default collection. Can be private or public collection
     *   @param {Object|Function} [args.itemContext] - object or function that's passed to the item view's during initialization under the name "context". Can be used by the item view during their prepare method.
     *   @param {HTML Template} [args.template] - allows a list view to hold it's own HTML like filter buttons, etc.
     *   @param {string} [args.itemContainer]  - (Required if 'template' is provided, ignored otherwise) name of injection site for list of item views
     *   @param {HTML Template} [args.emptyTemplate] - if provided, this template will be shown if the modelsToRender() method returns an empty list. If a itemContainer is provided, the empty template will be rendered there.
     *   @param {Function} [args.modelsToRender] - If provided, this function will override the modelsToRender() method with custom functionality.
     *   @param {number} [args.renderWait=0] - If provided, will collect any internally invoked renders (typically through collection events like reset) for a duration specified by renderWait in milliseconds and then calls a single render instead. Helps to remove unnecessary render calls when modifying the collection often.
     *   @param [args.modelId='cid'] {'cid' or 'id'} - model property used as identifier for a given model. This property is saved and used to find the corresponding view.
     *   @param [args.modelName='model'] {string} - name of the model argument passed to the item view during initialization
     */</span>
    <span class="hljs-keyword">constructor</span>: function(args) {
      View.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
      args = args || {};

      <span class="hljs-keyword">var</span> collection = args.collection || <span class="hljs-keyword">this</span>.collection;

      <span class="hljs-keyword">this</span>.template = args.template || <span class="hljs-keyword">this</span>.template;
      <span class="hljs-keyword">this</span>.emptyTemplate = args.emptyTemplate || <span class="hljs-keyword">this</span>.emptyTemplate;
      <span class="hljs-keyword">this</span>.itemView = args.itemView || <span class="hljs-keyword">this</span>.itemView;
      <span class="hljs-keyword">this</span>.itemContainer = args.itemContainer || <span class="hljs-keyword">this</span>.itemContainer;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.template &amp;&amp; !<span class="hljs-keyword">this</span>.itemContainer) {
        <span class="hljs-keyword">throw</span> <span class="hljs-string">'Item container is required when using a template'</span>;
      }
      <span class="hljs-keyword">this</span>.modelsToRender = args.modelsToRender || <span class="hljs-keyword">this</span>.modelsToRender;
      <span class="hljs-keyword">this</span>.__itemContext = args.itemContext || <span class="hljs-keyword">this</span>.__itemContext;
      <span class="hljs-keyword">this</span>.__modelToViewMap = {};
      <span class="hljs-keyword">this</span>.__renderWait = args.renderWait || <span class="hljs-keyword">this</span>.__renderWait;
      <span class="hljs-keyword">this</span>.__modelId = args.modelId || <span class="hljs-keyword">this</span>.modelId || <span class="hljs-string">'cid'</span>;
      <span class="hljs-keyword">this</span>.__modelName = args.modelName || <span class="hljs-keyword">this</span>.modelName || <span class="hljs-string">'model'</span>;
      <span class="hljs-keyword">this</span>.__orderedModelIdList = [];
      <span class="hljs-keyword">this</span>.__createItemViews();
      <span class="hljs-keyword">this</span>.__delayedRender = aggregateRenders(<span class="hljs-keyword">this</span>.__renderWait, <span class="hljs-keyword">this</span>);

      <span class="hljs-keyword">if</span> (collection) {
        <span class="hljs-keyword">this</span>.setCollection(collection, <span class="hljs-literal">true</span>);
      }
      <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'render:after-dom-update'</span>, <span class="hljs-keyword">this</span>.__cleanupItemViewsAfterAttachedToParent);
    },

    <span class="hljs-comment">/**
     * Sets the collection from which this view generates item views.
     * This method will attach all necessary event listeners to the new collection to auto-generate item views
     * and has the option of removing listeners on a previous collection. It will immediately update child
     * views and re-render if it is necessary - this behavior can be prevented with preventUpdate argument
     *
     * @param {Backbone.Collection instance} collection the new collection that this list view should use.
     * @param {boolean} preventUpdate if true, the list view will not update the child views nor rerender.
     */</span>
    setCollection: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">collection, preventUpdate</span>) </span>{
      <span class="hljs-keyword">this</span>.stopListening(<span class="hljs-keyword">this</span>.collection, <span class="hljs-string">'remove'</span>, removeItemView);
      <span class="hljs-keyword">this</span>.stopListening(<span class="hljs-keyword">this</span>.collection, <span class="hljs-string">'add'</span>, addItemView);
      <span class="hljs-keyword">this</span>.stopListening(<span class="hljs-keyword">this</span>.collection, <span class="hljs-string">'sort'</span>, <span class="hljs-keyword">this</span>.reorder);
      <span class="hljs-keyword">this</span>.stopListening(<span class="hljs-keyword">this</span>.collection, <span class="hljs-string">'reset'</span>, <span class="hljs-keyword">this</span>.update);

      <span class="hljs-keyword">this</span>.collection = collection;

      <span class="hljs-keyword">this</span>.listenTo(<span class="hljs-keyword">this</span>.collection, <span class="hljs-string">'remove'</span>, removeItemView);
      <span class="hljs-keyword">this</span>.listenTo(<span class="hljs-keyword">this</span>.collection, <span class="hljs-string">'add'</span>, addItemView);
      <span class="hljs-keyword">this</span>.listenTo(<span class="hljs-keyword">this</span>.collection, <span class="hljs-string">'sort'</span>, <span class="hljs-keyword">this</span>.reorder);
      <span class="hljs-keyword">this</span>.listenTo(<span class="hljs-keyword">this</span>.collection, <span class="hljs-string">'reset'</span>, <span class="hljs-keyword">this</span>.update);

      <span class="hljs-keyword">if</span> (!preventUpdate) {
        <span class="hljs-keyword">this</span>.update();
      }
    },

    <span class="hljs-comment">/**
     * Override of View.__updateDOM
     * Builds a single DOM fragment from the item views and attaches it at once.
     */</span>
    updateDOM: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> injectionSite,
        newDOM = $(templateRenderer.copyTopElement(<span class="hljs-keyword">this</span>.el));
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.template) {
        newDOM.html(<span class="hljs-keyword">this</span>.template(<span class="hljs-keyword">this</span>.prepare()));
        injectionSite = newDOM.find(<span class="hljs-string">'[inject='</span> + <span class="hljs-keyword">this</span>.itemContainer + <span class="hljs-string">']'</span>);
      } <span class="hljs-keyword">else</span> {
        injectionSite = $(<span class="hljs-string">'&lt;span&gt;'</span>);
        newDOM.append(injectionSite);
      }
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.hasItemViews()) {
        injectionSite.replaceWith(<span class="hljs-keyword">this</span>.__emptyAndRebuildItemViewsFragment());
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.emptyTemplate) {
        injectionSite.replaceWith(<span class="hljs-keyword">this</span>.emptyTemplate(<span class="hljs-keyword">this</span>.prepareEmpty()));
      }
      <span class="hljs-keyword">this</span>.$el.html(newDOM.contents());
    },

    <span class="hljs-comment">/**
     * Completes each item view's lifecycle of being attached to a parent.
     * Because the item views are attached in a non-standard way, it's important to make sure
     * that the item views are in the appropriate state after being attached as one fragment.
     * @private
     */</span>
    __cleanupItemViewsAfterAttachedToParent: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      _.each(<span class="hljs-keyword">this</span>.modelsToRender(), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model</span>) </span>{
        <span class="hljs-keyword">var</span> itemView = <span class="hljs-keyword">this</span>.getItemViewFromModel(model);
        <span class="hljs-keyword">if</span> (itemView) {
          itemView.delegateEvents();
          <span class="hljs-keyword">if</span> (!itemView.__attachedCallbackInvoked &amp;&amp; itemView.isAttached()) {
            itemView.__invokeAttached();
          }
          itemView.activate();
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Shouldn’t get here. Item view is missing…</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        }
      }, <span class="hljs-keyword">this</span>);
    },

    <span class="hljs-comment">/**
     * Loops through children views and renders them
     */</span>
    renderChildViews: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      _.each(<span class="hljs-keyword">this</span>.getTrackedViews({<span class="hljs-attr">child</span>: <span class="hljs-literal">true</span>}), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">childView</span>) </span>{
        childView.render();
      });
    },

    <span class="hljs-comment">/**
     * Takes existing item views and moves them into correct order defined by
     * this.modelsToRender(). <span class="hljs-doctag">NOTE:</span> As this method doesn't generate or remove views,
     * this method takes advantage of jquery's ability to move elements already attached to the DOM.
     */</span>
    reorder: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> firstItemView, sameOrder,
        elements = [],
        models = <span class="hljs-keyword">this</span>.modelsToRender(),
        newOrderOfIds = _.pluck(models, <span class="hljs-keyword">this</span>.__modelId),
        sizeOfNewModels = _.size(newOrderOfIds),
        sizeOfOldModels = _.size(<span class="hljs-keyword">this</span>.__orderedModelIdList),
        sameSize = sizeOfNewModels === sizeOfOldModels;

      <span class="hljs-keyword">if</span> (sameSize) {</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>is order the same?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        sameOrder = _.reduce(<span class="hljs-keyword">this</span>.__orderedModelIdList, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result, oldId, index</span>) </span>{
          <span class="hljs-keyword">return</span> result &amp;&amp; newOrderOfIds[index] == oldId;
        }, <span class="hljs-literal">true</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-string">'Reorder should not be invoked if the number of models have changed'</span>;
      }
      <span class="hljs-keyword">if</span> (!sizeOfNewModels || sameOrder) {</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>stop early if there are no models to reorder or the models are the same</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span>;
      }
      _.each(models, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model, index</span>) </span>{
        <span class="hljs-keyword">var</span> itemView = <span class="hljs-keyword">this</span>.getItemViewFromModel(model);
        <span class="hljs-keyword">if</span> (itemView) {
          elements.push(itemView.$el);
        }
        <span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span>) {
          firstItemView = itemView;
        }
      }, <span class="hljs-keyword">this</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>elements that are already connected to the DOM will be moved instead of re-attached
meaning that detach, delegate events, and attach are not needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.itemContainer) {
        <span class="hljs-keyword">this</span>.$el.append(elements);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (firstItemView) {
        <span class="hljs-keyword">var</span> injectionSite = $(<span class="hljs-string">"&lt;span&gt;"</span>);
        firstItemView.$el.before(injectionSite);
        injectionSite.after(elements);
        injectionSite.remove();
      }
      <span class="hljs-keyword">this</span>.__updateOrderedModelIdList(newOrderOfIds);
      <span class="hljs-keyword">this</span>.trigger(<span class="hljs-string">'reorder-complete'</span>);
    },

    <span class="hljs-comment">/**
     * Override if you want a different context for your empty template. Defaults to this.prepare()
     * @return a context that can be used by the empty list template
     */</span>
    prepareEmpty: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.prepare();
    },

    <span class="hljs-comment">/**
     * Returns an array of which models should be rendered.
     * By default, all models in the input collection will be
     * shown.  Extensions of this class may override this
     * method to apply collection filters.
     */</span>
    modelsToRender: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.collection ? <span class="hljs-keyword">this</span>.collection.models : [];
    },

    <span class="hljs-comment">/**
     * Builds any new views, removes stale ones, and re-renders
     */</span>
    update: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> oldViews = <span class="hljs-keyword">this</span>.getItemViews();
      <span class="hljs-keyword">var</span> newViews = <span class="hljs-keyword">this</span>.__createItemViews();
      <span class="hljs-keyword">var</span> staleViews = <span class="hljs-keyword">this</span>.__getStaleItemViews();
      <span class="hljs-keyword">var</span> sizeOfOldViews = _.size(oldViews);
      <span class="hljs-keyword">var</span> sizeOfNewViews = _.size(newViews);
      <span class="hljs-keyword">var</span> sizeOfStaleViews = _.size(staleViews);
      <span class="hljs-keyword">var</span> sizeOfFinalViews = sizeOfOldViews - sizeOfStaleViews + sizeOfNewViews;
      <span class="hljs-keyword">var</span> changes = sizeOfNewViews + sizeOfStaleViews;
      <span class="hljs-keyword">var</span> percentChange = changes / <span class="hljs-built_in">Math</span>.max(sizeOfFinalViews, <span class="hljs-number">1</span>);
      <span class="hljs-keyword">var</span> fromEmptyToNotEmpty = !sizeOfOldViews &amp;&amp; sizeOfNewViews;
      <span class="hljs-keyword">var</span> fromNotEmptyToEmpty = sizeOfOldViews &amp;&amp; sizeOfOldViews === sizeOfStaleViews &amp;&amp; !sizeOfNewViews;
      <span class="hljs-keyword">var</span> threshold = <span class="hljs-keyword">this</span>.updateThreshold || <span class="hljs-number">0.5</span>;
      <span class="hljs-keyword">var</span> signficantChanges = percentChange &gt;= threshold;
      <span class="hljs-keyword">if</span> (changes &lt;= <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.reorder();
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>A switch from empty to not empty or vise versa, needs a new render</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> renderNeeded = fromEmptyToNotEmpty || fromNotEmptyToEmpty || signficantChanges;
      <span class="hljs-keyword">if</span> (renderNeeded) {
        <span class="hljs-keyword">this</span>.__removeStaleItemViews(staleViews);
        <span class="hljs-keyword">this</span>.__delayedRender();
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>.__updateByAddingRemoving(oldViews, newViews, staleViews);
      }
    },

    <span class="hljs-comment">/**
     * Returns the view that corresponds to the model if one exists
     * @param {Model} model the model
     * @return the item view corresponding to the model
     */</span>
    getItemViewFromModel: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model</span>) </span>{
      <span class="hljs-keyword">return</span> model ? <span class="hljs-keyword">this</span>.getTrackedView(<span class="hljs-keyword">this</span>.__modelToViewMap[model[<span class="hljs-keyword">this</span>.__modelId]]) : <span class="hljs-literal">undefined</span>;
    },

    <span class="hljs-comment">/**
     * @return {boolean} returns true if there exists any generated item views
     */</span>
    hasItemViews: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> !_.isEmpty(<span class="hljs-keyword">this</span>.getItemViews());
    },

    <span class="hljs-comment">/**
     * @return {Array of views} Returns unordered list of views generated by this list view
     */</span>
    getItemViews: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> view = <span class="hljs-keyword">this</span>;
      <span class="hljs-keyword">var</span> orderedViewIds = _.map(<span class="hljs-keyword">this</span>.__orderedModelIdList, <span class="hljs-keyword">this</span>.__getViewIdFromModelId, <span class="hljs-keyword">this</span>);
      <span class="hljs-keyword">return</span> _.map(orderedViewIds, <span class="hljs-keyword">this</span>.getTrackedView, <span class="hljs-keyword">this</span>);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p><strong><strong><strong>**</strong></strong></strong> Private methods <strong><strong><strong>**</strong></strong></strong>//</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-comment">/**
     * Creates all needed item views that don't exist from modelsToRender()
     * @private
     * @return {Array} each object in array contains a 'view' and 'indexOfModel' field
     */</span>
    __createItemViews: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> newItemViews = [];
      _.each(<span class="hljs-keyword">this</span>.modelsToRender(), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model, indexOfModel</span>) </span>{
        <span class="hljs-keyword">var</span> itemView = <span class="hljs-keyword">this</span>.getItemViewFromModel(model);
        <span class="hljs-keyword">if</span> (!itemView) {
          newItemViews.push({
            <span class="hljs-attr">view</span>: <span class="hljs-keyword">this</span>.__createItemView(model, <span class="hljs-literal">true</span>),
            <span class="hljs-attr">indexOfModel</span>: indexOfModel
          });
        }
      }, <span class="hljs-keyword">this</span>);
      <span class="hljs-keyword">this</span>.__updateOrderedModelIdList();
      <span class="hljs-keyword">return</span> newItemViews;
    },

    <span class="hljs-comment">/**
     * Creates an item view and stores a reference to it
     * @private
     * @param {external:Backbone-Model} model the model to create the view from
     * @param [noUpdateToIdList=false] if true, the internal order of model ids are not updated
     * @return {Backbone View} the new item view
     */</span>
    __createItemView: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model, noUpdateToIdList</span>) </span>{
      <span class="hljs-keyword">var</span> itemView,
        ItemViewClass = <span class="hljs-keyword">this</span>.itemView;
      <span class="hljs-keyword">if</span> (!_.isFunction(<span class="hljs-keyword">this</span>.itemView.extend)) {
        ItemViewClass = <span class="hljs-keyword">this</span>.itemView(model);
      }
      itemView = <span class="hljs-keyword">new</span> ItemViewClass(<span class="hljs-keyword">this</span>.__generateItemViewArgs(model));
      <span class="hljs-keyword">this</span>.registerTrackedView(itemView, { <span class="hljs-attr">shared</span>: <span class="hljs-literal">false</span> });
      <span class="hljs-keyword">this</span>.__modelToViewMap[model[<span class="hljs-keyword">this</span>.__modelId]] = itemView.cid;
      <span class="hljs-keyword">if</span> (!noUpdateToIdList) {
        <span class="hljs-keyword">this</span>.__updateOrderedModelIdList();
      }
      <span class="hljs-keyword">this</span>.trigger(<span class="hljs-string">'child-view-added'</span>, {<span class="hljs-attr">model</span>: model, <span class="hljs-attr">view</span>: itemView});
      <span class="hljs-keyword">this</span>.trigger(<span class="hljs-string">'item-view-added'</span>, {<span class="hljs-attr">model</span>: model, <span class="hljs-attr">view</span>: itemView});
      <span class="hljs-keyword">return</span> itemView;
    },

    <span class="hljs-comment">/**
     * Gets all item views that have models that are no longer tracked by modelsToRender
     * @return {Array} An array of information about stale items. Each object has a 'view' and 'modelId' field
     * @private
     */</span>
    __getStaleItemViews: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> staleItemViews = [];
      <span class="hljs-keyword">var</span> modelsWithViews = _.clone(<span class="hljs-keyword">this</span>.__modelToViewMap);
      _.each(<span class="hljs-keyword">this</span>.modelsToRender(), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model</span>) </span>{
        <span class="hljs-keyword">var</span> itemView = <span class="hljs-keyword">this</span>.getItemViewFromModel(model);
        <span class="hljs-keyword">if</span> (itemView) {
          <span class="hljs-keyword">delete</span> modelsWithViews[model[<span class="hljs-keyword">this</span>.__modelId]];
        }
      }, <span class="hljs-keyword">this</span>);
      _.each(modelsWithViews, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">viewId, modelId</span>) </span>{
        <span class="hljs-keyword">var</span> itemView = <span class="hljs-keyword">this</span>.getTrackedView(viewId);
        <span class="hljs-keyword">if</span> (itemView) {
          staleItemViews.push({ <span class="hljs-attr">view</span>: itemView, <span class="hljs-attr">modelId</span>: modelId });
        }
      }, <span class="hljs-keyword">this</span>);
      <span class="hljs-keyword">return</span> staleItemViews;
    },

    <span class="hljs-comment">/**
     * Removes the item views that no longer have models returned by modelsToRender()
     * @param [staleItemViewInfo] {Array of objects:
     *   [{
     *     view: stale item view,
     *     modelId: id of model item
     *   }]} If provided, stale items will not be found, but this array will be used instead.
     * @private
     */</span>
    __removeStaleItemViews: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">staleItemViewInfo</span>) </span>{
      <span class="hljs-keyword">var</span> view = <span class="hljs-keyword">this</span>;
      staleItemViewInfo = staleItemViewInfo || <span class="hljs-keyword">this</span>.__getStaleItemViews();
      _.each(staleItemViewInfo, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">staleViewInfo</span>) </span>{
        _removeItemView.call(view, staleViewInfo.view, staleViewInfo.modelId);
      });
    },

    <span class="hljs-comment">/**
     * Creates a DOM fragment with each item view appended in the order defined by
     * modelsToRender(). This will clear the List View's DOM and invoke the necessary
     * detach, register and render logic on each item view.
     * @return a DOM fragment with item view elements appended
     * @private
     */</span>
    __emptyAndRebuildItemViewsFragment: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> injectionFragment = <span class="hljs-built_in">document</span>.createDocumentFragment();</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Clearing the DOM will reduce the repaints needed as we detach each item view.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">this</span>.$el.empty();

     _.each(<span class="hljs-keyword">this</span>.modelsToRender(), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model</span>) </span>{
        <span class="hljs-keyword">var</span> itemView = <span class="hljs-keyword">this</span>.getItemViewFromModel(model);
        <span class="hljs-keyword">if</span> (itemView) {</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>detach to be safe, but during a render, the item views will already be detached.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          itemView.detach();
          <span class="hljs-keyword">this</span>.registerTrackedView(itemView, { <span class="hljs-attr">shared</span>: <span class="hljs-literal">false</span> });
          itemView.attachTo(<span class="hljs-literal">null</span>, {
            <span class="hljs-attr">replaceMethod</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$el</span>) </span>{
              injectionFragment.appendChild($el[<span class="hljs-number">0</span>]);
            },
            <span class="hljs-attr">discardInjectionSite</span>: <span class="hljs-literal">true</span>
          });
        }
      }, <span class="hljs-keyword">this</span>);
      <span class="hljs-keyword">this</span>.__updateOrderedModelIdList();
      <span class="hljs-keyword">return</span> $(injectionFragment);
    },

    <span class="hljs-comment">/**
     * Attempts to insert new views and remove stale views individually and correctly reorder all views in an
     * attempt to be faster then a full view re-render
     * @param {Array of Views} oldViews - correctly ordered list of views before making changes to models to render
     * @param {Array of Views} newViews - the new views created that will be inserted
     * @param {Array of Views} staleViews - the stale views that will be removed
     */</span>
    __updateByAddingRemoving: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">oldViews, newViews, staleViews</span>) </span>{
      <span class="hljs-keyword">var</span> firstItemViewLeft, injectionSite,
        view = <span class="hljs-keyword">this</span>,
        sizeOfOldViews = _.size(oldViews),
        sizeOfNewViews = _.size(newViews),
        sizeOfStaleViews = _.size(staleViews);
      <span class="hljs-keyword">if</span> (view.itemContainer &amp;&amp; sizeOfOldViews &amp;&amp; sizeOfOldViews == sizeOfStaleViews) {</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>we removed all the views!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        injectionSite = $(<span class="hljs-string">'&lt;span&gt;'</span>);
        _.first(oldViews).$el.before(injectionSite);
      }
      view.__removeStaleItemViews(staleViews);
      _.each(newViews, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">createdViewInfo, indexOfView</span>) </span>{
        <span class="hljs-keyword">if</span> (createdViewInfo.indexOfModel === <span class="hljs-number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>need to handle this case uniquely.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> replaceMethod;
          <span class="hljs-keyword">if</span> (!view.itemContainer) {
            replaceMethod = _.bind(view.$el.prepend, view.$el);
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (injectionSite) {
              replaceMethod = _.bind(injectionSite.replaceWith, injectionSite);
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">var</span> staleModelIdMap = _.indexBy(staleViews, <span class="hljs-string">'modelId'</span>);
              <span class="hljs-keyword">var</span> firstModelIdLeft = _.find(view.__orderedModelIdList, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">modelId</span>) </span>{
                <span class="hljs-keyword">return</span> !staleModelIdMap[modelId];
              });
              firstItemViewLeft = view.getTrackedView(view.__modelToViewMap[firstModelIdLeft]);
              replaceMethod = _.bind(firstItemViewLeft.$el.prepend, firstItemViewLeft.$el);
            }
          }
          view.attachView(<span class="hljs-literal">null</span>, createdViewInfo.view, {
            <span class="hljs-attr">replaceMethod</span>: replaceMethod,
            <span class="hljs-attr">discardInjectionSite</span>: <span class="hljs-literal">true</span>
          });
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>There will always the view before this one because we are adding new views in order
and we took care of the initial case.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          _addItemView.call(view, createdViewInfo.view, createdViewInfo.indexOfModel);
        }
      });
      <span class="hljs-keyword">this</span>.reorder();
    },

    <span class="hljs-comment">/**
     * Updates the internal list of model ids that correspond to the models used for the current
     * list of item views. The order is the same order of the item views.
     * @param {Array of ids} [newIdsList] - if passed the array, it will use that instead of finding the list.
     * @private
     */</span>
    __updateOrderedModelIdList: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newIdsList</span>) </span>{
      <span class="hljs-keyword">this</span>.__orderedModelIdList = newIdsList || _.pluck(<span class="hljs-keyword">this</span>.modelsToRender(), <span class="hljs-keyword">this</span>.__modelId);
    },

    <span class="hljs-comment">/**
     * Method to generate arguments when creating an item view. Override this method
     * to change the arguments for a given item view.
     * The format of the subview's arguments is:
     * {
     *   context: {
     *     ... inherited from parent ...
     *   },
     *   &lt;modelName&gt;: &lt;modelObject&gt;,
     *   listView: the parent list view
     * }
     * @private
     * @param model the model for an item view
     * @return a context to be used by an item view
     */</span>
    __generateItemViewArgs: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model</span>) </span>{
      <span class="hljs-keyword">var</span> args = {
        <span class="hljs-string">'context'</span>: _.extend({}, _.result(<span class="hljs-keyword">this</span>, <span class="hljs-string">'__itemContext'</span>)),
        <span class="hljs-string">'listView'</span>: <span class="hljs-keyword">this</span>
      };
      args[<span class="hljs-keyword">this</span>.__modelName] = model;
      <span class="hljs-keyword">return</span> args;
    },

    <span class="hljs-comment">/**
     * Alias method for __generateItemViewArgs()
     */</span>
    __generateChildArgs: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.__generateItemViewArgs.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    },

    <span class="hljs-comment">/**
     * @private
     * @param {string|Number} modelId id of model
     * @return {string|Number} view cid that was built from corresponding model
     */</span>
    __getViewIdFromModelId: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">modelId</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.__modelToViewMap[modelId];
    }
  });

  <span class="hljs-keyword">return</span> ListView;
}));</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
